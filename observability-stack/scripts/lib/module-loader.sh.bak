#!/bin/bash
#===============================================================================
# Module Loader Library
# Functions for loading, validating, and managing exporter modules
#===============================================================================

# Guard against multiple sourcing
[[ -n "${MODULE_LOADER_LOADED:-}" ]] && return 0
MODULE_LOADER_LOADED=1

# Source common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# Module directories
MODULES_CORE_DIR="$(get_modules_dir)/_core"
MODULES_AVAILABLE_DIR="$(get_modules_dir)/_available"
MODULES_CUSTOM_DIR="$(get_modules_dir)/_custom"

#===============================================================================
# MODULE DISCOVERY
#===============================================================================

# List all available modules (from all directories)
# Usage: list_all_modules
list_all_modules() {
    local modules=()

    for dir in "$MODULES_CORE_DIR" "$MODULES_AVAILABLE_DIR" "$MODULES_CUSTOM_DIR"; do
        if [[ -d "$dir" ]]; then
            for module_dir in "$dir"/*/; do
                if [[ -f "${module_dir}module.yaml" ]]; then
                    modules+=("$(basename "$module_dir")")
                fi
            done
        fi
    done

    printf '%s\n' "${modules[@]}" | sort -u
}

# List core modules only
# Usage: list_core_modules
list_core_modules() {
    if [[ -d "$MODULES_CORE_DIR" ]]; then
        for module_dir in "$MODULES_CORE_DIR"/*/; do
            if [[ -f "${module_dir}module.yaml" ]]; then
                basename "$module_dir"
            fi
        done
    fi
}

# List available (community) modules
# Usage: list_available_modules
list_available_modules() {
    if [[ -d "$MODULES_AVAILABLE_DIR" ]]; then
        for module_dir in "$MODULES_AVAILABLE_DIR"/*/; do
            if [[ -f "${module_dir}module.yaml" ]]; then
                basename "$module_dir"
            fi
        done
    fi
}

# List custom modules
# Usage: list_custom_modules
list_custom_modules() {
    if [[ -d "$MODULES_CUSTOM_DIR" ]]; then
        for module_dir in "$MODULES_CUSTOM_DIR"/*/; do
            if [[ -f "${module_dir}module.yaml" ]]; then
                basename "$module_dir"
            fi
        done
    fi
}

# Get the directory path for a module
# Usage: get_module_dir "module_name"
get_module_dir() {
    local module_name="$1"

    for dir in "$MODULES_CORE_DIR" "$MODULES_AVAILABLE_DIR" "$MODULES_CUSTOM_DIR"; do
        if [[ -f "$dir/$module_name/module.yaml" ]]; then
            echo "$dir/$module_name"
            return 0
        fi
    done

    return 1
}

# Get the manifest file path for a module
# Usage: get_module_manifest "module_name"
get_module_manifest() {
    local module_name="$1"
    local module_dir

    module_dir=$(get_module_dir "$module_name") || return 1
    echo "$module_dir/module.yaml"
}

# Check if a module exists
# Usage: module_exists "module_name"
module_exists() {
    local module_name="$1"
    get_module_dir "$module_name" >/dev/null 2>&1
}

#===============================================================================
# MODULE MANIFEST PARSING
#===============================================================================

# Get a value from a module manifest
# Usage: module_get "module_name" "key"
module_get() {
    local module_name="$1"
    local key="$2"
    local manifest

    manifest=$(get_module_manifest "$module_name") || return 1
    yaml_get "$manifest" "$key"
}

# Get a nested value from a module manifest
# Usage: module_get_nested "module_name" "parent" "child"
module_get_nested() {
    local module_name="$1"
    local parent="$2"
    local child="$3"
    local manifest

    manifest=$(get_module_manifest "$module_name") || return 1
    yaml_get_nested "$manifest" "$parent" "$child"
}

# Get a deeply nested value from a module manifest
# Usage: module_get_deep "module_name" "level1" "level2" "level3"
module_get_deep() {
    local module_name="$1"
    local level1="$2"
    local level2="$3"
    local level3="$4"
    local manifest

    manifest=$(get_module_manifest "$module_name") || return 1
    yaml_get_deep "$manifest" "$level1" "$level2" "$level3"
}

# Get module version
# Usage: module_version "module_name"
module_version() {
    local module_name="$1"
    module_get_nested "$module_name" "module" "version"
}

# Get module display name
# Usage: module_display_name "module_name"
module_display_name() {
    local module_name="$1"
    module_get_nested "$module_name" "module" "display_name"
}

# Get module port
# Usage: module_port "module_name"
module_port() {
    local module_name="$1"
    module_get_nested "$module_name" "exporter" "port"
}

# Get module category
# Usage: module_category "module_name"
module_category() {
    local module_name="$1"
    module_get_nested "$module_name" "module" "category"
}

# Get module description
# Usage: module_description "module_name"
module_description() {
    local module_name="$1"
    module_get_nested "$module_name" "module" "description"
}

#===============================================================================
# MODULE DETECTION
#===============================================================================

# SECURITY: Safe command validator for detection rules
# Validates and executes only whitelisted commands to prevent injection attacks
# Usage: validate_and_execute_detection_command "command_string"
# Returns: 0 if command executed successfully and returned true, 1 otherwise
validate_and_execute_detection_command() {
    local cmd="$1"

    # SECURITY: Whitelist of allowed commands for detection
    # These are safe, read-only system inspection commands
    local -A ALLOWED_CMDS=(
        [systemctl]=1
        [which]=1
        [command]=1
        [test]=1
        [dpkg]=1
        [rpm]=1
        [ps]=1
        [netstat]=1
        [ss]=1
        [id]=1
        [getent]=1
    )

    # Parse the command to extract the base command
    local base_cmd
    base_cmd=$(echo "$cmd" | awk '{print $1}')

    # SECURITY: Reject if base command is not in whitelist
    if [[ -z "${ALLOWED_CMDS[$base_cmd]:-}" ]]; then
        log_debug "SECURITY: Rejected non-whitelisted command: $base_cmd"
        return 1
    fi

    # SECURITY: Additional validation - reject commands with dangerous characters
    if [[ "$cmd" =~ [\;\|\&\$\`] ]]; then
        log_debug "SECURITY: Rejected command with dangerous characters: $cmd"
        return 1
    fi

    # Execute the validated command safely
    # shellcheck disable=SC2086
    eval "$cmd" >/dev/null 2>&1
    return $?
}

# Run detection rules for a module
# Returns confidence score (0-100) or empty if not detected
# Usage: module_detect "module_name"
module_detect() {
    local module_name="$1"
    local manifest
    local confidence=0
    local matches=0
    local total_checks=0

    manifest=$(get_module_manifest "$module_name") || return 1

    # SECURITY: Check commands using safe whitelist validator (not arbitrary eval)
    while IFS= read -r cmd; do
        [[ -z "$cmd" ]] && continue
        ((total_checks++))
        if validate_and_execute_detection_command "$cmd"; then
            ((matches++))
            log_debug "Module $module_name: command '$cmd' matched"
        else
            log_debug "Module $module_name: command '$cmd' did not match or was invalid"
        fi
    done < <(yaml_get_array "$manifest" "detection.commands" 2>/dev/null)

    # Check systemd services
    while IFS= read -r svc; do
        [[ -z "$svc" ]] && continue
        ((total_checks++))
        if systemctl is-active --quiet "$svc" 2>/dev/null; then
            ((matches+=2))  # Weight systemd higher
            log_debug "Module $module_name: service '$svc' is active"
        elif systemctl is-enabled --quiet "$svc" 2>/dev/null; then
            ((matches++))
            log_debug "Module $module_name: service '$svc' is enabled"
        fi
    done < <(yaml_get_array "$manifest" "detection.systemd_services" 2>/dev/null)

    # Check files
    while IFS= read -r filepath; do
        [[ -z "$filepath" ]] && continue
        ((total_checks++))
        if [[ -e "$filepath" ]]; then
            ((matches++))
            log_debug "Module $module_name: file '$filepath' exists"
        fi
    done < <(yaml_get_array "$manifest" "detection.files" 2>/dev/null)

    # Calculate confidence
    if [[ $total_checks -gt 0 ]]; then
        # Base confidence from matches
        local base_confidence=$((matches * 100 / total_checks))

        # Get the module's max confidence from manifest
        local max_confidence
        max_confidence=$(yaml_get_nested "$manifest" "detection" "confidence")
        max_confidence=${max_confidence:-100}

        # Scale to max confidence
        confidence=$((base_confidence * max_confidence / 100))

        if [[ $confidence -gt 0 ]]; then
            echo "$confidence"
            return 0
        fi
    fi

    return 1
}

# Auto-detect all applicable modules for current host
# Returns: "module_name:confidence" lines sorted by confidence
# Usage: detect_all_modules
detect_all_modules() {
    local results=()

    while IFS= read -r module; do
        local confidence
        if confidence=$(module_detect "$module" 2>/dev/null); then
            results+=("$module:$confidence")
        fi
    done < <(list_all_modules)

    # Sort by confidence descending
    printf '%s\n' "${results[@]}" | sort -t: -k2 -rn
}

#===============================================================================
# MODULE VALIDATION
#===============================================================================

# Validate a module's manifest
# Usage: validate_module "module_name"
validate_module() {
    local module_name="$1"
    local manifest
    local errors=()

    manifest=$(get_module_manifest "$module_name")
    if [[ $? -ne 0 ]]; then
        log_error "Module '$module_name' not found"
        return 1
    fi

    # Check required fields
    local name
    name=$(module_get_nested "$module_name" "module" "name")
    if [[ -z "$name" ]]; then
        errors+=("Missing required field: module.name")
    fi

    local version
    version=$(module_version "$module_name")
    if [[ -z "$version" ]]; then
        errors+=("Missing required field: module.version")
    fi

    local port
    port=$(module_port "$module_name")
    if [[ -z "$port" ]]; then
        errors+=("Missing required field: exporter.port")
    elif ! [[ "$port" =~ ^[0-9]+$ ]]; then
        errors+=("Invalid port: $port (must be numeric)")
    fi

    # Check for required files
    local module_dir
    module_dir=$(get_module_dir "$module_name")

    if [[ ! -f "$module_dir/install.sh" ]]; then
        errors+=("Missing required file: install.sh")
    fi

    # Report results
    if [[ ${#errors[@]} -gt 0 ]]; then
        log_error "Module '$module_name' validation failed:"
        for error in "${errors[@]}"; do
            echo "  - $error"
        done
        return 1
    fi

    log_success "Module '$module_name' is valid"
    return 0
}

# Validate all modules
# Usage: validate_all_modules
validate_all_modules() {
    local has_errors=false

    while IFS= read -r module; do
        if ! validate_module "$module"; then
            has_errors=true
        fi
    done < <(list_all_modules)

    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    return 0
}

#===============================================================================
# HOST CONFIGURATION
#===============================================================================

# Get the configuration file path for a host
# Usage: get_host_config "hostname"
get_host_config() {
    local hostname="$1"
    echo "$(get_hosts_config_dir)/${hostname}.yaml"
}

# Check if a host has a configuration file
# Usage: host_config_exists "hostname"
host_config_exists() {
    local hostname="$1"
    [[ -f "$(get_host_config "$hostname")" ]]
}

# List all configured hosts
# Usage: list_configured_hosts
list_configured_hosts() {
    local hosts_dir
    hosts_dir=$(get_hosts_config_dir)

    if [[ -d "$hosts_dir" ]]; then
        for config in "$hosts_dir"/*.yaml; do
            if [[ -f "$config" ]]; then
                basename "$config" .yaml
            fi
        done
    fi
}

# Get a value from a host's configuration
# Usage: host_config_get "hostname" "key"
host_config_get() {
    local hostname="$1"
    local key="$2"
    local config

    config=$(get_host_config "$hostname")
    if [[ -f "$config" ]]; then
        yaml_get "$config" "$key"
    fi
}

# Get a nested value from a host's configuration
# Usage: host_config_get_nested "hostname" "parent" "child"
host_config_get_nested() {
    local hostname="$1"
    local parent="$2"
    local child="$3"
    local config

    config=$(get_host_config "$hostname")
    if [[ -f "$config" ]]; then
        yaml_get_nested "$config" "$parent" "$child"
    fi
}

# Check if a module is enabled for a host
# Usage: module_enabled_for_host "module_name" "hostname"
module_enabled_for_host() {
    local module_name="$1"
    local hostname="$2"
    local config

    config=$(get_host_config "$hostname")
    if [[ -f "$config" ]]; then
        local enabled
        enabled=$(yaml_get_deep "$config" "modules" "$module_name" "enabled")
        [[ "$enabled" == "true" ]]
    else
        return 1
    fi
}

# Get list of enabled modules for a host
# Usage: get_host_enabled_modules "hostname"
get_host_enabled_modules() {
    local hostname="$1"
    local config

    config=$(get_host_config "$hostname")
    if [[ ! -f "$config" ]]; then
        return 1
    fi

    # Parse modules section and filter by enabled: true
    awk '
        /^modules:/ { in_modules = 1; next }
        in_modules && /^[a-zA-Z_-]+:/ { in_modules = 0 }
        in_modules && /^  [a-zA-Z_-]+:/ {
            module = $1
            gsub(/:$/, "", module)
            current_module = module
        }
        in_modules && /^    enabled:/ {
            if ($2 == "true") {
                print current_module
            }
        }
    ' "$config"
}

# Get module configuration for a specific host
# Usage: get_host_module_config "hostname" "module_name" "config_key"
get_host_module_config() {
    local hostname="$1"
    local module_name="$2"
    local config_key="$3"
    local config

    config=$(get_host_config "$hostname")
    if [[ ! -f "$config" ]]; then
        return 1
    fi

    # This is a 4-level deep access: modules.<module_name>.config.<config_key>
    awk -v module="$module_name" -v key="$config_key" '
        BEGIN { in_module = 0; in_config = 0 }
        /^modules:/ { in_modules = 1; next }
        in_modules && /^  [a-zA-Z_-]+:/ {
            m = $1
            gsub(/:$/, "", m)
            in_module = (m == module)
            in_config = 0
        }
        in_module && /^    config:/ { in_config = 1; next }
        in_module && in_config && /^      [a-zA-Z_-]+:/ {
            k = $1
            gsub(/:$/, "", k)
            if (k == key) {
                sub(/^      [a-zA-Z_-]+:[[:space:]]*/, "")
                gsub(/^["'\''"]|["'\''"]$/, "")
                print
                exit
            }
        }
        in_module && /^    [a-zA-Z_-]+:/ && !/^    config:/ { in_config = 0 }
    ' "$config"
}

#===============================================================================
# MODULE INSTALLATION ROLLBACK
#===============================================================================

# Rollback state tracking
ROLLBACK_STATE_FILE="/tmp/observability-rollback-$$.state"
ROLLBACK_FILES_CREATED=()
ROLLBACK_SERVICES_ADDED=()
ROLLBACK_FIREWALL_RULES=()
ROLLBACK_USERS_CREATED=()

# Initialize rollback tracking
# Usage: init_rollback "module_name"
init_rollback() {
    local module_name="$1"

    # Create state file
    cat > "$ROLLBACK_STATE_FILE" << EOF
MODULE=$module_name
TIMESTAMP=$(date +%s)
FILES_CREATED=
SERVICES_ADDED=
FIREWALL_RULES=
USERS_CREATED=
EOF

    log_debug "Initialized rollback tracking for $module_name"
}

# Track a created file for rollback
# Usage: track_file_created "/path/to/file"
track_file_created() {
    local file="$1"
    ROLLBACK_FILES_CREATED+=("$file")
    echo "FILES_CREATED+=$file" >> "$ROLLBACK_STATE_FILE"
    log_debug "Tracking created file: $file"
}

# Track a created service for rollback
# Usage: track_service_added "service_name"
track_service_added() {
    local service="$1"
    ROLLBACK_SERVICES_ADDED+=("$service")
    echo "SERVICES_ADDED+=$service" >> "$ROLLBACK_STATE_FILE"
    log_debug "Tracking added service: $service"
}

# Track a firewall rule for rollback
# Usage: track_firewall_rule "rule_spec"
track_firewall_rule() {
    local rule="$1"
    ROLLBACK_FIREWALL_RULES+=("$rule")
    echo "FIREWALL_RULES+=$rule" >> "$ROLLBACK_STATE_FILE"
    log_debug "Tracking firewall rule: $rule"
}

# Track a created user for rollback
# Usage: track_user_created "username"
track_user_created() {
    local user="$1"
    ROLLBACK_USERS_CREATED+=("$user")
    echo "USERS_CREATED+=$user" >> "$ROLLBACK_STATE_FILE"
    log_debug "Tracking created user: $user"
}

# Perform rollback of installation
# Usage: rollback_installation
rollback_installation() {
    local module_name="${1:-unknown}"

    log_error "Installation failed. Rolling back changes for module: $module_name"

    # Load rollback state if file exists
    if [[ -f "$ROLLBACK_STATE_FILE" ]]; then
        source "$ROLLBACK_STATE_FILE" 2>/dev/null || true
    fi

    # Stop and remove services
    for service in "${ROLLBACK_SERVICES_ADDED[@]}"; do
        if [[ -n "$service" ]]; then
            log_info "Rollback: Stopping and removing service $service"
            systemctl stop "$service" 2>/dev/null || true
            systemctl disable "$service" 2>/dev/null || true
            rm -f "/etc/systemd/system/${service}.service" || true
        fi
    done

    # Remove firewall rules
    for rule in "${ROLLBACK_FIREWALL_RULES[@]}"; do
        if [[ -n "$rule" ]] && command -v ufw &>/dev/null; then
            log_info "Rollback: Removing firewall rule: $rule"
            ufw delete $rule 2>/dev/null || true
        fi
    done

    # Remove created files (in reverse order)
    for ((i=${#ROLLBACK_FILES_CREATED[@]}-1; i>=0; i--)); do
        local file="${ROLLBACK_FILES_CREATED[$i]}"
        if [[ -n "$file" ]] && [[ -e "$file" ]]; then
            log_info "Rollback: Removing file $file"
            rm -rf "$file" || true
        fi
    done

    # Remove created users
    for user in "${ROLLBACK_USERS_CREATED[@]}"; do
        if [[ -n "$user" ]] && id "$user" &>/dev/null; then
            log_info "Rollback: Removing user $user"
            userdel "$user" 2>/dev/null || true
            groupdel "$user" 2>/dev/null || true
        fi
    done

    # Reload systemd
    systemctl daemon-reload 2>/dev/null || true

    # Clean up state file
    rm -f "$ROLLBACK_STATE_FILE"

    log_warn "Rollback completed for module: $module_name"
}

# Clean up successful installation tracking
# Usage: cleanup_rollback
cleanup_rollback() {
    rm -f "$ROLLBACK_STATE_FILE"
    ROLLBACK_FILES_CREATED=()
    ROLLBACK_SERVICES_ADDED=()
    ROLLBACK_FIREWALL_RULES=()
    ROLLBACK_USERS_CREATED=()
}

#===============================================================================
# MODULE INSTALLATION
#===============================================================================

# Run a module's installation script
# Usage: install_module "module_name" [extra_args...]
install_module() {
    local module_name="$1"
    shift
    local module_dir

    module_dir=$(get_module_dir "$module_name") || {
        log_error "Module '$module_name' not found"
        return 1
    }

    local install_script="$module_dir/install.sh"
    if [[ ! -f "$install_script" ]]; then
        log_error "Install script not found for module '$module_name'"
        return 1
    fi

    log_info "Installing module: $module_name"

    # Initialize rollback tracking
    init_rollback "$module_name"

    # Export rollback functions for use in install scripts
    export -f track_file_created
    export -f track_service_added
    export -f track_firewall_rule
    export -f track_user_created
    export -f log_debug
    export -f log_info
    export -f log_warn
    export -f log_error

    # Source the install script with module context
    export MODULE_NAME="$module_name"
    export MODULE_DIR="$module_dir"
    export MODULE_VERSION
    MODULE_VERSION=$(module_version "$module_name") || {
        log_error "Failed to get version for module '$module_name'"
        return 1
    }
    export MODULE_PORT
    MODULE_PORT=$(module_port "$module_name") || {
        log_error "Failed to get port for module '$module_name'"
        return 1
    }

    # Run the install script with error handling
    if bash "$install_script" "$@"; then
        log_success "Module '$module_name' installed successfully"
        cleanup_rollback
        return 0
    else
        local exit_code=$?
        log_error "Module '$module_name' installation failed with exit code $exit_code"
        rollback_installation "$module_name"
        return 1
    fi
}

# Uninstall a module
# Usage: uninstall_module "module_name" [--purge]
uninstall_module() {
    local module_name="$1"
    local purge="${2:-}"
    local module_dir

    module_dir=$(get_module_dir "$module_name") || {
        log_error "Module '$module_name' not found"
        return 1
    }

    local uninstall_script="$module_dir/uninstall.sh"
    if [[ -f "$uninstall_script" ]]; then
        log_info "Uninstalling module: $module_name"
        if bash "$uninstall_script" "$purge"; then
            log_success "Module '$module_name' uninstalled successfully"
            return 0
        else
            log_error "Module '$module_name' uninstallation failed"
            return 1
        fi
    else
        log_warn "No uninstall script found for module '$module_name'"
        return 1
    fi
}

#===============================================================================
# MODULE INFORMATION DISPLAY
#===============================================================================

# Display detailed information about a module
# Usage: show_module_info "module_name"
show_module_info() {
    local module_name="$1"

    if ! module_exists "$module_name"; then
        log_error "Module '$module_name' not found"
        return 1
    fi

    local module_dir
    module_dir=$(get_module_dir "$module_name")
    local manifest="$module_dir/module.yaml"

    local display_name version description port category

    display_name=$(module_display_name "$module_name")
    version=$(module_version "$module_name")
    description=$(module_description "$module_name")
    port=$(module_port "$module_name")
    category=$(module_category "$module_name")

    echo ""
    echo "Module: $module_name"
    echo "========================================"
    echo "Display Name: ${display_name:-$module_name}"
    echo "Version:      $version"
    echo "Port:         $port"
    echo "Category:     ${category:-uncategorized}"
    echo "Description:  ${description:-No description}"
    echo ""
    echo "Location: $module_dir"
    echo ""
    echo "Files:"
    # Use find instead of ls parsing
    if [[ -d "$module_dir" ]]; then
        find "$module_dir" -maxdepth 1 -type f -printf "  %p\n" 2>/dev/null | sort
    fi
    echo ""

    # Check if has dashboard
    if [[ -f "$module_dir/dashboard.json" ]]; then
        echo "Dashboard:    Yes"
    else
        echo "Dashboard:    No"
    fi

    # Check if has alerts
    if [[ -f "$module_dir/alerts.yml" ]]; then
        echo "Alert Rules:  Yes"
    else
        echo "Alert Rules:  No"
    fi

    echo ""
}

# List modules with their status
# Usage: list_modules_status
list_modules_status() {
    echo ""
    printf "%-25s %-10s %-6s %-12s %s\n" "MODULE" "VERSION" "PORT" "CATEGORY" "DESCRIPTION"
    printf "%-25s %-10s %-6s %-12s %s\n" "-------------------------" "----------" "------" "------------" "--------------------"

    while IFS= read -r module; do
        local version port category description

        version=$(module_version "$module")
        port=$(module_port "$module")
        category=$(module_category "$module")
        description=$(module_description "$module")

        # Truncate description to 40 chars
        if [[ ${#description} -gt 40 ]]; then
            description="${description:0:37}..."
        fi

        printf "%-25s %-10s %-6s %-12s %s\n" \
            "$module" \
            "${version:-N/A}" \
            "${port:-N/A}" \
            "${category:-N/A}" \
            "${description:-N/A}"
    done < <(list_all_modules)

    echo ""
}
